[
  [
    "関数を宣言する正しい構文は？",
    ["function greet() {}", "def greet() {}", "func greet() {}", "function: greet() {}"],
    "function greet() {}",
    "① function greet() {} → 正解。functionキーワードで関数を定義<br>② def greet() {} → defはPythonの構文<br>③ func greet() {} → funcはGoなどで使われる<br>④ function: greet() {} → function: は構文エラー"
  ],
  [
    "関数式の正しい書き方は？",
    ["const add = function(a, b) { return a + b; }", "function = const(a, b) => a + b", "def = (a, b) => a + b", "add: function(a, b) {}"],
    "const add = function(a, b) { return a + b; }",
    "① const add = function(a, b) { return a + b; } → 正解。無名関数を変数に代入する形<br>② function = const(a, b) => a + b → 左右の構文が逆で構文エラー<br>③ def = (a, b) => a + b → defはJSには存在しない<br>④ add: function(a, b) {} → add: function はオブジェクトリテラル内でのみ有効"
  ],
  [
    "アロー関数の特徴として正しいのは？",
    ["thisを束縛しない", "functionよりも処理が遅い", "必ずreturnが必要", "再代入できない"],
    "thisを束縛しない",
    "① thisを束縛しない → 正解。アロー関数は外側のthisを引き継ぐ<br>② functionよりも処理が遅い → 処理速度に差はほぼない<br>③ 必ずreturnが必要 → returnは省略可能な場合がある<br>④ 再代入できない → 関数自体は変数に代入していれば再代入できる"
  ],
  [
    "関数のスコープとして正しいのは？",
    ["関数内で宣言した変数は外からアクセスできない", "関数外の変数は関数内から見えない", "関数の中でも変数はすべてグローバル", "関数内で宣言された変数は常にconstになる"],
    "関数内で宣言した変数は外からアクセスできない",
    "① 関数内で宣言した変数は外からアクセスできない → 正解。関数スコープの基本<br>② 関数外の変数は関数内から見えない → 外側の変数はスコープに入っていれば見える<br>③ 関数の中でも変数はすべてグローバル → グローバルになるのは明示的にそうした場合のみ<br>④ 関数内で宣言された変数は常にconstになる → 宣言方法によりvar/let/constが変わる"
  ],
  [
    "グローバルスコープに定義される変数は？",
    ["関数外で宣言された変数", "関数内のlet変数", "ブロック内のconst変数", "関数引数"],
    "関数外で宣言された変数",
    "① 関数外で宣言された変数 → 正解。関数外で宣言された変数はグローバルスコープになる<br>② 関数内のlet変数 → letはブロックスコープ<br>③ ブロック内のconst変数 → constもブロックスコープ<br>④ 関数引数 → 引数は関数内のローカルスコープ"
  ],
  [
    "関数を即時実行する正しい構文は？",
    ["(function() { /* 処理 */ })();", "function() {}();", "def() {}", "const run = () => {}; run();"],
    "(function() { /* 処理 */ })();",
    "① (function() { /* 処理 */ })(); → 正解。IIFE（即時実行関数）の基本形<br>② function() {}(); → 無名関数を直接実行はできない（構文エラー）<br>③ def() {} → defはJSでは無効<br>④ const run = () => {}; run(); → runを定義して手動で呼び出す形なので即時実行とは異なる"
  ],
  [
    "関数内から値を返すには？",
    ["return文を使う", "print文を使う", "console.logで返す", "sendで送る"],
    "return文を使う",
    "① return文を使う → 正解。戻り値を返すにはreturn<br>② print文を使う → printは存在しない（他言語）<br>③ console.logで返す → console.logは表示するだけ<br>④ sendで送る → sendはJSの関数で返却用途ではない"
  ],
  [
    "関数のデフォルト引数の使い方で正しいのは？",
    ["function greet(name = 'Guest') {}", "function greet(name := 'Guest') {}", "function greet(name == 'Guest') {}", "function greet(let name = 'Guest') {}"],
    "function greet(name = 'Guest') {}",
    "① function greet(name = 'Guest') {} → 正解。ES6以降で使える構文<br>② function greet(name := 'Guest') {} → := は他言語（例：Pythonのウォルラス演算子）<br>③ function greet(name == 'Guest') {} → == は比較演算子で代入ではない<br>④ function greet(let name = 'Guest') {} → 関数引数でletは使えない"
  ],
  [
    "関数の中で定義した関数のことをなんという？",
    ["ネストされた関数", "外部関数", "ルート関数", "スーパーファンクション"],
    "ネストされた関数",
    "① ネストされた関数 → 正解。関数の中にある関数はネストと呼ばれる<br>② 外部関数 → 外部関数は外側にある関数を指す<br>③ ルート関数 → ルート関数という用語は存在しない<br>④ スーパーファンクション → スーパーファンクションという概念もない"
  ],
  [
    "クロージャーとは何か？",
    ["関数が外部の変数を記憶する仕組み", "関数が即時実行される構文", "関数をループで使う方法", "関数のスコープがグローバルになる仕組み"],
    "関数が外部の変数を記憶する仕組み",
    "① 関数が外部の変数を記憶する仕組み → 正解。クロージャーはスコープを閉じ込める<br>② 関数が即時実行される構文 → 即時実行はIIFE<br>③ 関数をループで使う方法 → クロージャーはループとは無関係<br>④ 関数のスコープがグローバルになる仕組み → スコープがグローバルになるわけではない"
  ]
]