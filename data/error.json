[
  [
    "JavaScriptで例外を投げるための正しい構文は？",
    ["throw new Error('メッセージ')", "error('メッセージ')", "raise Error('メッセージ')", "exception Error('メッセージ')"],
    "throw new Error('メッセージ')",
    "① throw new Error('メッセージ') → 正解。throwでErrorオブジェクトを投げるのが標準的<br>② error('メッセージ') → error()という関数は存在しない<br>③ raise Error('メッセージ') → raiseはPythonなど他言語の構文で、JSにはない<br>④ exception Error('メッセージ') → exceptionも構文エラーとなる"
  ],
  [
    "try...catch文でcatchに渡される引数は何？",
    ["throwされたエラーオブジェクト", "関数の戻り値", "HTTPレスポンス", "undefinedになる"],
    "throwされたエラーオブジェクト",
    "① throwされたエラーオブジェクト → 正解。catch(e) のeにはthrowされたエラーが渡る<br>② 関数の戻り値 → 関数の戻り値ではない<br>③ HTTPレスポンス → ネットワーク通信の結果とは無関係<br>④ undefinedになる → catchには必ず引数が渡される"
  ],
  [
    "Errorオブジェクトの標準プロパティはどれ？",
    ["message", "stack", "reason", "causeMessage"],
    "message",
    "① message → 正解。エラーメッセージの文字列を保持する<br>② stack → stackは非標準だが多くの実装で利用される<br>③ reason → reasonは標準には存在しない<br>④ causeMessage → causeMessageというプロパティは存在しない"
  ],
  [
    "tryブロック内でエラーが起きなかった場合、catchブロックはどうなる？",
    ["実行されない", "スキップされてdefaultに飛ぶ", "エラーになる", "自動的に再実行される"],
    "実行されない",
    "① 実行されない → 正解。catchは例外が発生した場合のみ実行<br>② スキップされてdefaultに飛ぶ → defaultはswitch構文に関するもので関係ない<br>③ エラーになる → エラーにはならない<br>④ 自動的に再実行される → 自動で再実行はされない"
  ],
  [
    "catchの中でさらにエラーが発生したらどうなる？",
    ["外側のtryでcatchできる", "無視されて続行する", "プログラムが強制終了する", "エラーは自動的に再試行される"],
    "外側のtryでcatchできる",
    "① 外側のtryでcatchできる → 正解。ネストされたtry構文で外側が受け止めることが可能<br>② 無視されて続行する → 無視されるわけではない（tryなしならUncaught Error）<br>③ プログラムが強制終了する → JSでは未捕捉エラーでもブラウザが強制終了することはない<br>④ エラーは自動的に再試行される → 再試行は自動では行われない"
  ],
  [
    "Promiseのcatchメソッドの役割は？",
    ["非同期エラーを処理する", "同期処理の結果を待つ", "Promiseをキャンセルする", "thenの代わりに使う"],
    "非同期エラーを処理する",
    "① 非同期エラーを処理する → 正解。Promiseで発生したエラーを補足する<br>② 同期処理の結果を待つ → 同期処理とは直接関係しない<br>③ Promiseをキャンセルする → Promiseのキャンセル機能は標準には存在しない<br>④ thenの代わりに使う → thenとcatchは用途が異なる"
  ],
  [
    "finallyブロックの特徴は？",
    ["エラーの有無に関係なく実行される", "エラー時だけ実行される", "catchがある場合にのみ動く", "処理が中断される"],
    "エラーの有無に関係なく実行される",
    "① エラーの有無に関係なく実行される → 正解。tryでもcatchでも、必ずfinallyは実行される<br>② エラー時だけ実行される → エラーの有無に関係ないのが特徴<br>③ catchがある場合にのみ動く → catchの有無に関係なく使える<br>④ 処理が中断される → finallyが処理を中断するわけではない"
  ],
  [
    "Errorオブジェクトに独自の情報を追加したいとき、どのようにする？",
    ["プロパティを追加する", "Errorを継承するしかない", "console.logに渡す", "throwの中でJSONを返す"],
    "プロパティを追加する",
    "① プロパティを追加する → 正解。Errorオブジェクトに任意のプロパティを付加可能<br>② Errorを継承するしかない → 継承しなくても追加は可能<br>③ console.logに渡す → console.logは表示するだけで、オブジェクトに何も追加されない<br>④ throwの中でJSONを返す → throwではJSONを返すことはできず、エラーとして扱われない"
  ],
  [
    "非同期関数でtry...catchを使うとき、何に気をつける？",
    ["awaitで発生する例外も捕捉される", "catchが無視される", "finallyがスキップされる", "awaitはtryの外で使う必要がある"],
    "awaitで発生する例外も捕捉される",
    "① awaitで発生する例外も捕捉される → 正解。awaitが失敗すると例外がthrowされcatchで補足可能<br>② catchが無視される → catchは無視されず確実に呼ばれる<br>③ finallyがスキップされる → finallyも実行される<br>④ awaitはtryの外で使う必要がある → awaitはtryの中でも使える"
  ],
  [
    "エラーハンドリングに関するベストプラクティスは？",
    ["具体的なエラーを捕捉し、適切に処理する", "すべてのエラーを無視する", "throwの代わりにalertを使う", "catchでは何もしないのが最適"],
    "具体的なエラーを捕捉し、適切に処理する",
    "① 具体的なエラーを捕捉し、適切に処理する → 正解。意味のあるエラーハンドリングが必要<br>② すべてのエラーを無視する → 無視はセキュリティや信頼性の問題になる<br>③ throwの代わりにalertを使う → alertは通知に過ぎず、例外処理ではない<br>④ catchでは何もしないのが最適 → catchで何もしないのは危険"
  ]
]